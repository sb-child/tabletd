/// 提供数位板事件对外分发的服务端接口
pub mod event_dispatcher;

// 控制面板后端
pub mod control;

/// 数位板驱动相关逻辑实现
pub mod tablet_driver;

/// HUD (Head-Up Display) 界面逻辑
pub mod hud_interface;

/// 屏幕叠加层接口，用于显示光标和 HUD
// TODO: 人工修一下cursor整的烂活
// pub mod screen_overlay;

/// 原始输入接口实现（如 USB 和蓝牙设备）
pub mod input_devices;

/// 数位板事件的内部路由逻辑
pub mod event_router;

/// 数位板事件的抽象层，定义事件模型
pub mod event_model;

// `screen_overlay`要做的事情就是给每个显示器都创建一个全屏overlay
// 然后通过DMA或者什么东西暴露出接口，由`hud_interface`渲染每个overlay的界面
// 至于光标要不要单独整一个overlay.. 如果移动它的效率很高，而且开销比重新渲染更低，那可以考虑这样

// 至于光标的设计嘛，我在想一种动态的光标：笔悬在空中时，它显示为一个空心圆形，
// 支持倾斜感应的话，这个圆形可以相应的倾斜为椭圆，倾斜角对应圆形的变换程度，用深浅两个颜色代表具体的倾斜方向
// 笔按下之后，椭圆立刻过渡成实心圆形, 它的半径取决于按压力度，实心圆形内部绘制一个扇形图案代表倾斜角度和方向

// 需要能够处理接入多个数位板的情况，每个光标可以使用不同颜色标注，光标旁可以显示文字
// 当然还有不同屏幕，甚至有人喜欢给不同的屏幕设置不同的缩放比例

// wayland协议并不支持分数缩放，看样子这是混成器自己搞的奇怪东西，把buffer放大又缩小
// 在 event_model 或 event_dispatcher 层面实现对分数缩放的支持。
// 将逻辑坐标转换为整数缩放比例，并通过 Wayland 提供的 API 调整输出分辨率。
// 提供用户选项，允许手动指定分数缩放比例。

// HUD `hud_interface` 用来显示提示信息(我挺喜欢 osu!lazer 那个风格), 比如数位板接入，拔出等事件
// 当然，三星的 s pen 也可以抄抄，比如按下笔上的按钮之后弹出快捷菜单
// 数位板上通常会有button和wheel, 它们可以用来唤起 HUD
// HUD 应该且只能由数位板操控，所以这就是为什么我还create了`event_router`

// `event_router`作为`event_model`到`event_dispatcher`的桥梁，但是`event_router`可以在特定情况下阻止事件向后传递(比如唤起了HUD)
// 但是为了最大限度的互操作性和扩展性, `event_router` 并不会真的把事件拦在路上，它会给由内部处理的事件加个tag，代表程序不应该响应它
// 至于为什么要这样设计，那是因为我还打算整个自己的 `tabletd API`

// `tabletd API` 是个极其变态的东西，它允许 `tabletd` 作为服务端向 `tabletd` 客户端转发数位板事件，又名「远程数位板」，
// 而且它可以走各种socket，只要保证对面能连上就行
// `tabletd API` 会发送所有的事件，除非用户设置了过滤条件

// `event_dispatcher` 是数位板事件的出口，它一般会和 `wayland`, `libinput`, `tabletd API` 等接口对接，
// 当然，被拦截的事件只会通过 `tabletd API` 发出去，不然 HUD 就像一个透明窗口，事件全都流出给下层窗口了

// `event_model` 是一个极其抽象的数位板，我希望它能覆盖到市面上所有不带屏的数位板的全部功能，因为数位屏不是数位板，万一你带触摸呢

// `input_devices` 包括了连接到数位板的各种方式，比如USB和蓝牙，和`tabletd API`的各种传输途径(http, tcp, udp(?), unix socket 甚至 `iroh` 等等)，
// 当然，最常见的蓝牙其实传输的是绝对鼠标，看样子也发来了压感，按键等数据
// 但是我需要完全接管这个设备，不能让它被 bluetoothctl(bluez) 之类的系统服务把它变成 /dev 下的input设备(这样会极其麻烦)

// `tablet_driver` 这就是整个项目最容易的部分，数位板驱动
// 当然也包括 `tabletd API`
// 这部分可以照抄 `opentabletdriver`
// 妈的我挖坑`tabletd`就是因为`opentabletdriver`进展巨慢，gui和gui库一起爆炸了，有几率使gnome崩溃，而且不合我的pr

// 数位板 -> 屏幕的映射
//     映射跨越屏幕：
//         可以实现跨屏映射，通过统一的逻辑管理所有屏幕的坐标系，使用每个屏幕的缩放比例进行适配。
//         例如，保持一个全局的逻辑坐标系（例如 0-1 范围的归一化坐标），然后根据屏幕的实际分辨率和缩放比例动态计算物理坐标。
//     HUD 显示的位置:
//         可以默认在主屏幕显示 HUD，或跟随数位板的主要活动区域。
//         如果跨屏幕操作频繁，可以考虑在每个屏幕上显示一个 HUD 的副本，并保持同步。
//     光标处理:
//         光标需要根据缩放比例动态调整大小和位置，且确保光标在用户移动时不会因缩放比例不同而产生跳跃感。
//         提供用户设置，允许指定每个屏幕的显示优先级或禁用跨屏操作。
//     技术实现:
//         使用 Wayland 或 X11 的多屏幕 API 获取各屏幕的分辨率和缩放比例。
//         提供用户配置文件，允许自定义屏幕映射行为。

// 数位板唯一ID
// 统一设备管理层:
//     在 event_router 或 input_devices 层面实现统一的设备管理，将 USB 和蓝牙的连接信息映射到同一逻辑设备 ID。
//     例如，通过设备的唯一硬件标识符（如序列号、MAC 地址等）来确保一致性。
// 自动检测机制:
//     在设备连接时，检查其硬件特性，动态分配或更新设备 ID。
//     针对蓝牙设备，可以通过蓝牙协议的设备名称或属性匹配 USB 设备。
// 技术实现:
//     使用 libudev 或类似工具获取设备硬件信息（如 Vendor ID 和 Product ID）。
//     在蓝牙连接时，查询设备属性并尝试匹配已知的 USB 设备。

// 查找所有可能的 Wayland socket:
//     在 /run/user/<UID> 下查找所有以 wayland- 开头的 socket 文件。
//     例如，通过遍历 /run/user/<UID>/wayland-* 并尝试连接。
// 多个混成器的处理:
//     如果多个 Wayland 混成器同时运行，可以尝试优先连接主会话的 socket（例如 wayland-0）。
//     提供用户配置选项，允许用户手动指定 socket。
// 技术实现:
//     在启动时自动扫描可能的 socket 路径。
//     提供命令行参数或配置文件，允许用户手动覆盖默认的 socket。
//     如果发现多个混成器，记录日志并提示用户选择。

// GUI 就用 preact + socket.io 吧
// socket.io 后端是 `webui_backend`
